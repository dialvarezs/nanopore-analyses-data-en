Temas a abordar:
- Ensamblaje de genomas con Canu y Flye
- Corrección de ensamblajes
- Métricas de evaluación de ensamblajes

### Ensamblaje

El ensamblaje de genomas tiene como objetivo unir fragmentos de ADN, mediante solapamientos de lecturas u otras técnicas, para obtener (idealmente), un solo contig con el genoma reconstruido. Uno de los enfoques más utilizados para realizar ensamblaje se basa en la búsqueda de superposiciones entre las lecturas con el objetivo de ensamblarlos en contigs de mayor longitud.

Existen dos tipos de ensamblaje, `ensamblaje de novo`, y `ensamblaje comparativo`. El  `ensamblaje de novo` utiliza solamente la información producida en la secuenciación para reconstruir el genoma, mientras que el `ensamblaje comparativo` utiliza una referencia como base para realizar el ensamblaje.

Las tecnologías de secuenciación de segunda generación producen lecturas de entre 20pb a 500pb, lo cual dificulta el proceso de ensamblaje de regiones repetitivas o regiones de gran longitud. Es por ello, que utilizar tecnologias de tercera generación se logra reducir el costo al ensamblar genomas o regiones con las caracteristicas mencionadas anteriormente, gracias a la capacidad de generar lecturas de varias kilobases.

NCBI cuenta con una plataforma que permite visualizar todos los ensamblajes subidos a la base de datos, junto con su tamaño, descripción taxonómica, y la cantidad de ensamblajes de cada organismo. ([Página](https://www.ncbi.nlm.nih.gov/genome/browse/#!/overview/))

Algunos términos a conocer en esta área:
- `contig (Contiguous sequence)`: Secuencia de ADN que procede de dos o más secuencias que se superponen en sus extremos y se ensamblaron y juntaron en una sola secuencia no redundante.  No poseen gaps
- `scaffold`: Secuencias que se forman a partir de la unión de `contigs`. Pueden poseer gaps y generalmente se utilizan para ensamblar cromosomas.
- `draft genome`: Ensamblaje de genoma no finalizado, cubre generalmente entre el 9% y el 95% del genoma objetivo.
- `Anotación`: Asignación de una función a un gen conocido. 

![[Advantages-of-long-read-assembly-Shown-here-is-a-genome-sequence-with-3-unique-segments-_1_ 1.png]]

#### Canu
[Repositorio oficial](https://github.com/marbl/canu) || [Documentación](https://canu.readthedocs.io/en/latest/quick-start.html)

Canu es una herramienta de ensamblaje que permite el ensamblaje de datos provenientes de tecnologías de secuenciación con alta tasa de error.

Canu realiza un ensamblaje jerárquico y consta de cuatro etapas:
- Detecta superposiciones en las lecturas.
- Genera una secuencia consenso corregida.
- Recorta las secuencias corregidas
- Ensambla las secuencias corregidas recortadas

Canu necesita saber el tamaño aproximado del genoma a ensamblar, y en base al valor indicado, calcula la profundidad (este es un primer filtro de `canu`m en caso de tener una profundidad muy baja no se ejecutará el ensamblaje). Canu indica que un mínimo de profundidad de 20x para ensamblajes híbridos es suficiente, pero recomienda valores de profundidad de entre 30x y 60x. 

Canu posee varios parámetros que permiten caracterizar las secuencias a ensamblar ( `-pacbio`,  `-pacbio-hifi`, `-nanopore`,  `trimmed`, `-untrimmed`, `-raw`, `-corrected`), los cuales indican básicamente la tecnología de secuenciación utilizada y el estado de las lecturas (procesadas o sin procesar).

Se puede instalar el paquete vía conda y verificar su versión. Canu muchas veces tiene incompatibilidades con otras herramientas instaladas en el mismo enviroment, por lo que siempre hay que verificar que se esté usando la versión correcta.

```bash
conda install -c bioconda canu 
canu --help
canu --version
```


El comando `canu` ejecuta la corrección, trimming y ensamblaje de secuencias en un solo paso. Se le puede indicar la cantidad de `threads` a utilizar, al igual que la cantidad máxima de memoria. Con el comando `genomeSize` se indica el tamaño esperado del genoma a ensamblar.

`Canu` utiliza un prefijo para almacenar los archivos generados, el cual debe indicarse con el parámetro `-p`, el directorio donde se almacenarán los archivos finales se indica con el parámetro `-d`.
```bash
 canu -p OB -d O2_17kb genomeSize=17k -nanopore OB.fastq.gz maxThreads=4 maxMemory=12G 
```
En caso de que se quiera correr cada caso de canu por separado, se pueden ejecutar los comandos:
- `canu -correct`: Ejecutar solo la corrección de las lecturas.
- `canu -trim`: Ejecutar solo el recorte de extremo en las lecturas.
- `canu -trimmed -corrected`: Ensamblar utilizando como input lecturas ya corregidas y recortadas (solo se ejecutará el ensamblaje).

Al ejecutar `canu`se generará un directorio con los siguientes outputs: 
- `<prefix>`.report: Contiene toda la información del ensamblaje (histograma de lecturas, cantidad de lecturas corregidas y recortadas, estadísticas básicas del ensamblaje).
- `<prefix>.corrctedReads.fasta.gz`: Lecturas corregidas.
- `<prefix>.trimmedReads.fasta.gz`: Lecturas corregidas y recortadas a los extremos.
- `<prefix>.contigs.fasta`: Contigs provenientes de las lecturas ensambladas.
- `<prefix>.unassembled.fasta`: Lecturas y contigs que no lograron ensamblar, o no se consideraron  en el ensamblaje final por su baja cobertura de profundad.

Los contigs generados se nombran dependiendo de la información obtenida durante el ensamblaje, parten con `>tig` y continuación tendrá la siguiente metadata:
- `len`: Indica el tamaño del contig generado.
- `reads`: Indica la cantidad de lecturas utilizadas para realizar el ensamblaje.
- `class`: Indica el tipo de secuencia (contig o secuencia sin ensamblar).
- `suggestRepeat`: Indica si la secuencia ensamblada es detectada como parte de una región repetitiva.
- `suggestBubble`: 
- `suggestCircular`: Indica si la secuencia ensamblada posee un genoma circular.
	- `trim`: En caso de ser un genoma circular, el parámetro `trim`, indicará las coordenadas de la región no redundante.

El ejemplo siguiente muestra una secuencia ensamblada a nivel de contig de 199kb (199.460 pb), formado con la unión de 184 lecturas. El contig generado es probablemente circular, y la parte no repetitiva esta entre las bases 16.382 159.495. 
```bash
>tig00000001 len=199460 reads=184 class=contig suggestRepeat=no suggestBubble=no suggestCircular=yes trim=16383-159494
```


#### Flye
[Repositorio](https://github.com/fenderglass/Flye) || [Documentación](https://github.com/fenderglass/Flye/blob/flye/docs/USAGE.md)

Flye es un ensamblador de novo para lecturas de secuenciación de una sola molécula, como por ejemplo, Oxford Nanopore y PacBio. `Flye` presenta un flujo de trabajo completo, permitiendo corregir las lecturas antes de ensamblarlas.
También permite ensamblar genomas completos y ensamblar metagenomas.

Al igual que `canu`, `flye` posee un conjunto de parámetros que permiten caracterizar la secuencia a ensamblar, dependiendo del porcentaje de error y la tecnología de secuenciación utilizada:
`--pacbio-raw`: Lecturas provenientes de PacBio CLR reads (con menos de un 20% de error).
- `--pacbio-corr`: Lecturas provenientes de PacBio corregidas (con menos de un 3% de error).
- `--pacbio-hifi`: Lecturas provenientes de PacBio HiFi, con menos de un 1% de error.
`--nano-raw`: Lecturas provenientes de Oxford Nanopore obtenidas con versiones de Guppy menores a la 5 (menos de un 20% de error).
- `--nano-corr`: Lecturas provenientes de Oxford Nanopore corregidas (menos de un 3% de error).
- `--nano-hq`: Lecturas provenientes de Oxford Nanopore Q20 u obtenidas con versiones de Guppy superiores a la versión 5 (menos de un 5% de error).

`Flye` no requiere indicar el tamaño del genoma esperado a ensamblar, pero se puede hacer con el parámetro `--genome-size`. Mediante el parámetro `meta` se puede indicar que se quieren ensamblar metagenomas. 
En caso de poseer un ensamblaje obtenido con otra herramienta, se puede utilizar el  `--polish-target`, para realizar solamente un pulido al ensamblaje de interés.

Una ejecución simple de  `flye`,  una ejecución sencilla utilizando los parámtros por defecto se presenta a continuación: 
```bash
flye --nano-raw sequences.fasta --out-dir out_nano --threads 4
```

`Flye` entrega como output tres archivos:
- `assembly.fasta`: Ensamblaje final.
- `assembly_graph.{gfa|gv}`: Grafo de repeticiones generado.
- `assembly_info.txt`: Información de los contigs ensamblados (tamaño, cobertura, genoma circular, genoma repetitivo, etc.)

* `NOTA`: El uso de los parámetros  `--asm-coverage` y `--min-overlap` ayuda a la reducción del uso de memoria, recursos computacionales y tiempos de ejecución.

#### Medaka
[Repositorio](https://github.com/nanoporetech/medaka) || []()

Medaka es una herramienta desarrollada por Oxford Nanopore y recomendada para pulir ensamblajes o secuencias consenso.

Se puede instalar mediante conda:
```bash
conda install -c bioconda medaka
```

Medaka utiliza modelos para mejorar los consensos y llamadas de variantes, basados en el basecaller utilizado para obtener las secuencias. Se pueden visualizar los modelos disponibles con el comando `medaka tools list_models`.  Los modelos dependerán del poro utilizado, el dispositivo de secuenciación utilizado, y el tipo de basecalling. Los nombres de los modelos siguen el siguiente formato:

```bash
{pore}_{device}_{caller variant}_{caller version}

r941_min_fast_g303
# Data obtenida mediante secuenciación con celda con química 9.4.1 y dispositivo minion.
# El basecalling se realizó con el módelo rapido, y con la versión de guppy 3.0.3
```

Es importante tener actualizado `medaka` ya que en caso de utilizar versiones antiguas, no se encontrarán los modelos más adecuados a utilizar, lo que afectará el rendimiento del consenso o detección de variantes.

A continuación se presenta una ejecución sencilla de `medaka` para generar un conceso pullido:
```bash 
medaka_consensus -o assembly_medaka.fasta -t 4 -i sequences.fasta -d assembly
```
En caso de no indicar el modelo de utilizará el por defecto (se puede visualizar con `medaka_consensus -h`). En caso de querer indicar un modelo se debe inidcar con el parámetro `-m`. A continuación se presenta un ejemplo incluyendo el modelo a utilizar 
```bash 
medaka_consensus -o assembly_medaka.fasta -t 4 -i basecalled_reads.fastq -d assembly -m r941_min_hac_g507
```


#### Quast
[Repositorio](https://github.com/ablab/quast) || [Documentación](http://bioinf.spbau.ru/quast)

Quast permite la evaluación de ensamblajes de genomas o metagenomas mediante el cálculo de varias métricas. Permite la comparación de métricas de diferentes ensamblajes y la comparación con una secuencia de referencia también.

Se puede instalar vía conda y verificar su versión y ayuda:
```bash
conda install -c bioconda quast
quast --help
quast --version 
```

#### CheckV
[Repositorio](https://bitbucket.org/berkeleylab/checkv/src/master/)

CheckV permite la evaluación de calidad de genomas virales de un solo contig, incluye la identificación de contaminación del huésped para provirus integrados, estimación de integridad de fragmentos del genoma e identificación de los genomas cerrados.

Se puede instalar vía conda
```bash
conda install -c bioconda checkv

checkv --help
```


CheckV necesita contar con su base de datos para los análisis, la cual puede descargarse con el siguiente comando: 
```bash
checkv download_database ./
```

Para este curso la base de datos se encontrará en el directorio `/opt/data/assembly/checkv-db-v1.4/`, para indicarle al comando donde se encuentra almacenada la db se puede utilizar la opción `-d`.

CheckV cuenta con los siguientes subcomandos:
- `contamination`: Identificación y eliminación de contaminación del host y provirus integrados.
- `completeness`:  Estimación de completitud del genoma
- `complete_genomes`:  Identificación de completitud basado en terminales repetitivos y regiones flank del host.
- `quality_summary`: Resumen de los resultados de los modulos.

En caso de querer realizar todos los análisis mencionados anteriormente, checkV cuenta con el subcomando `end_to_end` (estimación de completitud, contaminación, e identificación de genomas cerrados)

Para correr el flujo de trabajo completo se debe indicar el archivo que contiene el ensamblaje, el directorio donde esta almacenado la db y el directorio donde se almacenaran los resultados:

```bash
checkv end_to_end assembly.fasta checv_results -d ~/checkv-db-v1.4/
```

El detalle de las metodologías utilizadas se puede encontrar en la sección `How it works` de la [documentación oficial](https://bitbucket.org/berkeleylab/checkv/src/master/).

#### Busco
[Documentación](https://busco.ezlab.org/busco_userguide.html#automated-lineage-selection) || [FTP](https://busco-data.ezlab.org/v5/data/)

BUSCO es una herramienta para medir la completitud de genomas. Utiliza como base para su medición los *genes ortólogos*, los cuales están altamente conservados entre especies cercanas.

```bash
conda install -c conda-forge -c bioconda busco
```

Se puede visualizar la lista de dataset disponibles con el comando `busco --list-datasets`. `Busco` permite descargar automáticamente bases de datos de *genes ortólogos/copia única*, pero también se pueden descargar directamente desde su [FTP](https://busco-data.ezlab.org/v5/data/lineages/). 

Una ejecución sencilla de `BUSCO` se presenta a continuación: 
```bash
busco --in assembly.fasta --mode genome --lineage_dataset vibrionales_odb10 --out  busco_out 
```

`Busco` genera reportes en formato de texto y formato tabular con la información de los genes encontrados. Los archivos más relevantes se describen a continuación:
- `short_summary.*.txt`:  Resumen de la búsqueda de genes. Contiene la cantidad de genes buscados, encontrados, no encontrados, y encontrados de manera incompleta. En base a la cantidad de genes encontrados se calcula el porcentaje de completitud.
- `full_table.tsv`:  Por cada gen prpresenten la base de datos de `busco` se informa su estado (completo, incompleto, no encontrado). En caso de encotrar el gen se indica en que secuencia esta presente, y las posiciones.
- `missing_busco_list.tsv`: Lista de genes no encontrados en el ensamblaje.



#### Tarea 2
Realizar ensamblaje con las herramientas `flye` y `canu` y realizar una comparativa entre los resultados obtenidos con ambas herramientas.
- Realizar descontaminación de los datos con `blast` o `mmseqs2` (pueden apoyarse con la herramienta `seqkit` para eliminar secuencias contaminadas)
- Utilizar la herramienta `quast` para medir el ensamblaje
- Obtener estadísticas de profundidad por base con `samtools depth`
- Medir la completitud del genoma con la herramienta `checkv` ([Repositorio](https://bitbucket.org/berkeleylab/checkv/src/master/))

Indicar en el informe:
- Versión de las herramientas utilizadas
- Cantidad de secuencias total: Secuencias sin procesar, secuencias pre ensamblaje
- Cantidad de secuencias eliminadas por descontaminación
- Indicar la profundidad utilizada para ensamblar y en caso de utilizar parámetros adicionales, se deben indicar.
- Estadísticas de profundidad, junto con un gráfico y análisis de zonas de alta y baja profundidad.
- Resumen de los resultados de ensamblaje (cantidad de contigs, completitud, contaminación, etc)

Notas:
- Para armar la base de datos de contaminantes deben utilizar el archivo  `/Documentos/data/Tarea2/nt.saureus_filtered.20200110.fasta`.
- Utilizar las secuencias filtradas generadas en la tarea 1.

Recordatorio:
- `AB`: Ivan Moya (150Kb  - Host: Staphylococcus aureus)  
- `OA`: Pedro Simeone (17Kb - Host: Staphylococcus aureus)  
- `CA`: Estefania Jofré(150Kb - Host: Staphylococcus aureus)  
- `CB`: Carolina Pérez(150Kb - Host: Staphylococcus aureus)  
- `O2`: Alonso De la Rivera(17kb - Host:  Staphylococcus aureus)


Sugerencias:
- Para la descontaminación se recomienda utilizar un `evalue` de 0.00001
- Se recomienda probar la herramienta `mmseqs2` debido al alto costo en tiempo que implica `blast`
- Para filtrar los resultados de `blast` (o cualquier formato tabular) se puede utilizar el comando `cut -f1` para extraer solo la primera columna (se le puede indicar la columna a recuperar cambiando el número). Pueden complementarlo con el comando `unique` mediante el operador pipe, para eliminar aquellas filas repetidas.
- Se recomienda utilizar `tmux` para la creación de terminales. ([CheatSheet](https://tmuxcheatsheet.com))
- Pueden utilizar la herramienta [filtlong](https://github.com/rrwick/Filtlong) para realizar un filtro de los datos por calidad, como por ejemplo quedarse solo con una cantidad determinada de profundidad objetivo (para ello considerará todas aquellas con mejor calidad hasta llegar al valor objetivo).

Plazo de entrega: 19 de abril
Clase de consultas (opcional): 12 de abril 